<?php


namespace ID\KeyManager\Factories;


use ID\KeyManager\Repositories\KeyRepository;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;
use InvalidArgumentException;
use phpseclib\Crypt\AES;
use phpseclib\Crypt\RSA;

class KeyFactory
{
    public const DEFAULT_SIZE = 4096;

    /**
     * @var Application|mixed|RSA
     */
    private $generator;

    /**
     * @var array
     */
    protected array $config;

    /**
     * @var string
     */
    private ?string $password = null;

    /**
     * @var mixed
     */
    protected $privateKey;

    /**
     * @var mixed
     */
    protected $publicKey;

    /**
     * @var mixed
     */
    private $partKey;

    /**
     * @var KeyRepository
     */
    protected KeyRepository $repository;

    /**
     * @var bool
     */
    private bool $finished = false;

    /**
     * KeyFactory constructor.
     *
     * @param array         $config
     * @param KeyRepository $repository
     */
    public function __construct(KeyRepository $repository, ?array $config = null)
    {
        if ($config) {
            $this->load($config);
        }
        $this->repository = $repository;
    }

    /**
     * @param array $config
     *
     * @return static
     */
    public function generate(?array $config = null): self
    {
        if ($config) {
            $this->load($config);
        }
        $this->generateKeyPair();
        return $this;
    }

    /**
     * @param array $config
     *
     * @return KeyFactory
     */
    public function load(array $config): self
    {
        if (!key_exists('type', $config)) {
            throw new InvalidArgumentException(
                sprintf('The configuration "%s" does NOT specify a key type', Arr::get($config, 'filename'))
            );
        }
        $this->setGenerator($config['type']);
        unset($config['type']);
        if (Arr::pull($config, 'password', false)) {
            $this->setPassword(Str::random(16));
        }
        $this->config = $config;
        return $this;
    }

    /**
     * @param string $generator
     */
    private function setGenerator(string $generator)
    {
        switch ($generator) {
            case RSA::class:
                $this->generator = app(RSA::class);
                break;
            case AES::class:
                $this->generator = app(AES::class);
                break;
            default:
                throw new InvalidArgumentException("The requested key type is not supported");
                break;
        }
    }

    private function generateKeyPair(): void
    {
        if (!$this->generator) {
            throw new \RuntimeException("There was NOT a defined generator or an invalid one was found.");
        }
        if (!!$this->password) {
            $this->generator->setPassword($this->password);
        }
        $this->generator->setComment("Generated by ID at " . time());
        $resource = $this->generator->createKey(
            Arr::get($this->config, 'size', self::DEFAULT_SIZE),
            2000,
            true
        );
        list($this->privateKey, $this->publicKey, $this->partKey) = array_values($resource);
        if (!!$this->privateKey && !!$this->publicKey) {
            $this->finished = true;
        }
    }

    /**
     * @param string $password
     *
     * @return KeyFactory
     */
    public function setPassword(string $password): KeyFactory
    {
        $this->password = $password;
        return $this;
    }

    /**
     * @return bool
     */
    public function save(): bool
    {
        return $this->repository->saveFromFactory($this);
    }

    /**
     * @return mixed
     */
    public function getPrivateKey()
    {
        return $this->privateKey;
    }

    /**
     * @return mixed
     */
    public function getPublicKey()
    {
        return $this->publicKey;
    }

    /**
     * @return bool
     */
    public function isFinished(): bool
    {
        return $this->finished;
    }

    /**
     * @return array
     */
    public function getConfig(): array
    {
        return $this->config;
    }

}
